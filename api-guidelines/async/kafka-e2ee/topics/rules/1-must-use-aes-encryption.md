---
id: 1
---

# MUST use AES encryption for the payload

The message payload is encrypted with AES 256 GCM encryption.
The parameters which are used for the encryption are the initialization vector (`IV`) 
and the key.

In the generated kafka message the `IV` MUST be transported as a kafka header.
Keep in mind that the auth tag which is generated by the AES encryption is appended
to the encrypted buffer. There can be a different approach depending on your programming language.

## Java algorithm example

Encrpyting a payload:

```java
String payloadInPlainText = "-test-test-test-";
// read key from KMS
String keyInKmsBase64Encoded = "VU9NkNuLU6jTPpSF04rKvM1aL0zPlOurtsU+tB5oABc=";
// generate a new Initialization Vector for each message
String newIvBase64Encoded = "IRq/OWo8IEj9StG0";
byte[] key = Base64.getDecoder().decode(keyInKmsBase64Encoded);
byte[] iv = Base64.getDecoder().decode(newIvBase64Encoded);
byte[] plaintext = payloadInPlainText.getBytes(StandardCharsets.UTF_8);
Cipher enc = Cipher.getInstance("AES/GCM/NoPadding");
enc.init(
        Cipher.ENCRYPT_MODE,
        new SecretKeySpec(key, "AES"),
        new GCMParameterSpec(128, iv));
byte[] encrypted = enc.doFinal(plaintext);
```

Decrypting a payload:

```java
byte[] encryptedPayload = Base64.getDecoder().decode("X7ILrF+H/2pQdo93U83rzkDn35Ezok6XPMRfTvDWstA=");
// extract keyVersion from the KafkaHeader "encryption/ciphers"
String keyInKmsBase64Encoded = "VU9NkNuLU6jTPpSF04rKvM1aL0zPlOurtsU+tB5oABc="
// extract Initialization Vector from Kafka header "encryption/iv"
String ivBase64Encoded = "IRq/OWo8IEj9StG0"
byte[] key = Base64.getDecoder().decode(keyInKmsBase64Encoded);
byte[] iv = Base64.getDecoder().decode(ivBase64Encoded);
Cipher dec = Cipher.getInstance("AES/GCM/NoPadding");
dec.init(
        Cipher.DECRYPT_MODE,
        new SecretKeySpec(key, "AES"),
        new GCMParameterSpec(128, iv));
byte[] decrypted = dec.doFinal(encryptedPayload);
String payloadInPlainText = new String(decrypted, StandardCharsets.UTF_8);:w
```

## Typescript algorithm example

```typescript
export class AES {
    static encrypt(key : Buffer, iv : Buffer, text : string) : Buffer {
        const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
        const encrypted = Buffer.concat([
            cipher.update(String(text), 'utf8'),
            cipher.final(),
        ]);

        const tag = cipher.getAuthTag();

        return Buffer.concat([encrypted, tag]);
    }

    static decrypt(key : Buffer, iv : Buffer, cipherText : Buffer) : string {
        const encryptedWithTag = cipherText;
        const encryptedData = encryptedWithTag.subarray(0, encryptedWithTag.length - 16);
        const tag = encryptedWithTag.subarray(encryptedWithTag.length - 16, encryptedWithTag.length)
        const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);

        decipher.setAuthTag(tag);

        return decipher.update(encryptedData) + decipher.final('utf8');
    }
}
```

## Golang algorithm example

```golang
func Decrypt(cipherText, key, iv string) ([]byte, error) {

	keyBytes, base64Err := DecodeBase64(key)
	cipherTextBytes, base64Err := DecodeBase64(cipherText)
	nonce, base64Err := DecodeBase64(iv)
	if base64Err != nil {
		return nil, base64Err
	}

	block, decryptError := aes.NewCipher(keyBytes)
	if decryptError != nil {
		return nil, decryptError
	}

	aesgcm, decryptError := cipher.NewGCM(block)
	if decryptError != nil {
		return nil, decryptError
	}

	decrypted, decryptError := aesgcm.Open(nil, nonce, cipherTextBytes, nil)
	if decryptError != nil {
		return nil, decryptError
	}

	return decrypted, decryptError
}

```